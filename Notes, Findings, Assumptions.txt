Notes –Given the CountMeUP Scenario, I started developing it using the SDLC (Planning, Analysis, Design and Implementation) and some principles of the Agile methodology.So, first I identified the requirements, broke it down into user stories and decided to start by developing the first endpoint of the system the frontend. I decided to create a simple and static webpage which display a chart that increments with the votes given, and it updates every 1 second.Technology chosen:Front end (Client- side), :-	HTML,-	Bootstrap (CSS, Stylesheet)-	Angular.js,-	FusionCharts,(library for the chart)Backend (Server-side) programming languages and libraries:-	Python3-	mongodp (database)-	Pymongo (access the database)RESTful API:-	Json-	Flask (microframework of the server)Working Environment:-	 Brackets (HTML editor and live preview)-	Web Browser-	Mac Terminal-	Python IDLE For the web framework – After some research I got to a conclusion that CherryPy and Flask would be the best choices for interaction with Python and after a few tests on CherryPy and Flask felt more comfortable with Flask. There are more frameworks that I could have used but I decided for those who use simple HTTP method to make calls between the end points (GET, and POST).Flask is a microframework which does not come with all the API functionality, as CherryPy would have, so for database abstraction I used the Pymongo instead.  The main reason that I have chosen Flask was because of its simplicity and for the purpose of this assignment I think it suits well.----First Part – Front end.I first started creating the web structure and I wrote some mock data as part of the TDD development.I chose Angular.js to build the client-side because I found it simpler and easier to manipulate. Also because of the directives and controllers, which makes the code more readable. It is also simpler than JQuery.Bootstrap was the first choice for the design, because it works very well with responsive web development.During this process, my assumptions were:-	I came with an idea to build a bar chart, which shows the partial results within the time frame given (unknown, but I assumed was until reach the votes partition given), and I was thought to build an area where the user could vote as well so I could show the 3 votes allowance.-	I decided to go for this approach because after analysing many times the program specs I concluded that the requirements are 10 Million votes distributed between the candidates, local user can vote up to three time, and the other votes are simulated by the program until you get the numbers given within the timeframe and then the presenter can announce the winner.-	However, after a few tests, during the backend development I decided to remove and make random creation of users applying to the rule that only the 3 firsts votes would count.-	Questions that I looked up:How do I validate the local votes?Should I do a register or get the device IP number to make 3 three votes rules?The votes simulation how long it should last, and what order should it be given?Second Part Backend.I started to develop the set of rules and methods in app.py file and connect then to app.js and index.html using the @sign, then did the tests and start to see the results.Then, created some test scenarios to check if it meets the requirements.Had some problems with passing the information to the chart and as the rules for the 3 votes are in the app.py, create a test scenario for run in the shell.Some more Assumptions and finds.-	I first wrote a test that returns the exactly number of the percentage partition scenarioTest2.py. -	However, after looking again the scenario given I had to create another scenario test  scenarioTest4.py hard coding the final result because candidate 4 is short of 500k and candidate 5 is short of 1 million.-	The speed of showing the results decreases when the number of votes is larger and many times stops showing the data, perhaps fusion charts was not the best option. The backend still working smoothly but the frontend is not working as expected.To finalize I made some modification in the CountMeUp.py and in the app.py, and app.js to make then more simple and readable so some tests scenario may not continue to work.Count me up works as expected and as there was no time frame given (that I assumed is the caped number of votes for each candidate), so it works as real election votes counting.For more speed, I would have to give some votes before start counting but it is just an assumption I have not tried with the version. In conclusion, the reason that I have chosen the technology resources was mainly because of as simplicity and readability, with I had more time I would look for more robust solutions and make increments but for now I believe it does the work.